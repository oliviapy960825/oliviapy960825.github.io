package ps6;

import java.util.Arrays;

/**
 * A basic TicTacToe game model that has been modified to allow
 * play on a NxN board. In addition, pieces may be specified to 
 * be empty, x, o, or blocked (neither player can place a piece there).
 * 
 * @author jatlas
 */
public class TicTacToeNxN extends CharBoardGame {
    public static final char X = 'x';
    public static final char O = 'o';
    public static final char B = '#'; // blocked
    
    public TicTacToeNxN(char[][] board) {
        super(board);
    }
        
    /**
     * Gets the maximum sequential times that the given symbol appears
     * in a linear iteration of the board. Starts at row, column and iterates by
     * dr, dc each loop iteration as long as row, column are within
     * bounds. 
     */
    public int getMaxSequence(int row, int column, int dr, int dc, char symbol) {
        // You must complete this method
    	int sum=0;
    	if(dr!=0){
    	for(int goThroughRow=row;goThroughRow<board.length-1;goThroughRow+=dr){
    		if(dc!=0){
    			for(int goThroughCol=column;goThroughCol<board[goThroughRow].length-1;goThroughCol+=dc){
    				if(board[goThroughRow][goThroughCol]==symbol&&board[goThroughRow+1][goThroughCol+1]==symbol){
    					sum+=2;
    				}
    				else{
    					sum++;
    				}
    			}
    		}
    		else{
    			if(board[goThroughRow][column]==symbol&&board[goThroughRow+1][column]==symbol){
    				sum+=2;
    			}
    			else{
    				sum++;
    			}
    		}
    	}
    	}
    	else{
    		if(dc!=0){
    			for(int goThroughCol=column;goThroughCol<board[row].length-1;goThroughCol+=dc){
    				if(board[row][goThroughCol]==symbol&&board[row][goThroughCol+1]==symbol){
    					sum+=2;
    				}
    				else{
    					sum++;
    				}
    			}
    		}
    		else{
    				sum++;
    		}
    	}
        return sum;
    }
    
    /**
     * Gets the score for the given symbol in the board. The score is
     * the max value from all results returned from calling getMaxSequence
     * for each unique left-to-right, top-to-bottom, down-right-diagonal, 
     * and down-left-diagonal path.
     * 
     * Technically we shouldn't check all of the diagonals but it won't hurt
     * because we are just finding a max.
     */
    public int getScore(char symbol) {
        int maxScore = 0;
        // assumes the board is a square
        for (int i = 0; i < board.length; i++) {
            // check the row indicated by i
            maxScore = Math.max(maxScore, getMaxSequence(i, 0, 0, 1, symbol));
            // check the column indicated by i
            maxScore = Math.max(maxScore, getMaxSequence(0, i, 1, 0, symbol));
            // check the left-to-right diagonals indicated by i
            maxScore = Math.max(maxScore, getMaxSequence(i, 0, 1, 1, symbol));
            maxScore = Math.max(maxScore, getMaxSequence(0, i, 1, 1, symbol));
            // check the right-to-left diagonals indicated by i
            maxScore = Math.max(maxScore, getMaxSequence(i, 0, 1, -1, symbol));
            maxScore = Math.max(maxScore, getMaxSequence(i, board.length-1, 1, -1, symbol));
        }
        return maxScore;
    }
    
    public static TicTacToeNxN makeStartGame(int n) {
        // creates a starting board
        char[][] board = new char[n][n];
        for (char[] row : board) {
            Arrays.fill(row, E);
        }
        if (n > 4) {
            board[n/2][n/2] = B; // center square in NxN > 4 is blocked
        }
        return new TicTacToeNxN(board);
    }
}
